/******************************************************************
 * File: source//script_parser.h
 *
 * This file was automatically generated by CppCC Version 0.0.6
 * DO NOT EDIT MANUALLY
 ******************************************************************/


#ifndef __SCRIPT_PARSER_HH__
#define __SCRIPT_PARSER_HH__

#include <iostream>
#include <string>
#include <exception>

#include "script_token.h"
#include "script_scanner.h"
namespace script_tut
{

class ParseException : public std::exception
{
  public:
    
    ParseException (const std::string &message_ = "Parse exception") :
      message(message_)
    {}
    
    ParseException (const Position &pos_,
                   const std::string &message_ = "Parse exception") :
      message(message_), pos(pos_)
    {}
    
    ~ParseException () throw ()
    {}
    
    virtual operator std::string () const
    {
      return std::string(pos) + ": " + message;
    }
    
    virtual const char* what () throw ()
    {
      return message.c_str();
    }
    
    virtual Position& where () throw ()
    {
      return pos;
    }
    
  private:
  
    Position pos;
    std::string message;
}; // end class PasreException


class scriptParser_base
{
  protected:
    bool onParseError (ParseException &pex) { return false; }
};


class scriptParser : public scriptParser_base
{
  public: // methods
    
    scriptParser (std::istream *in_ = NULL) :
       scanner(in_), _la(0)
    {}
    
    // productions entry points:
    
    void
     file ();
    void
     statement ();
    void
     compound_statement ();
    void
     if_statement ();
    void
     expression ();
    void
     assign_expression ();
    void
     concat_expression ();
    void
     logical_OR_expression ();
    void
     logical_AND_expression ();
    void
     equal_expression ();
    void
     add_expression ();
    void
     mult_expression ();
    void
     func_call_expression ();
    void
     argument_list ();
    void
     value_expression ();
    
    // productions LA methods:
    
    bool __la_file_ ();
    bool __la_statement_ ();
    bool __la_compound_statement_ ();
    bool __la_if_statement_ ();
    bool __la_expression_ ();
    bool __la_assign_expression_ ();
    bool __la_concat_expression_ ();
    bool __la_logical_OR_expression_ ();
    bool __la_logical_AND_expression_ ();
    bool __la_equal_expression_ ();
    bool __la_add_expression_ ();
    bool __la_mult_expression_ ();
    bool __la_func_call_expression_ ();
    bool __la_argument_list_ ();
    bool __la_value_expression_ ();
    
    // lookahead entry points:
    
    // LA entry points for file
    
    // LA entry points for statement
    
    // LA entry points for compound_statement
    
    // LA entry points for if_statement
    
    bool __la_0_ (int depth);
    // LA entry points for expression
    
    // LA entry points for assign_expression
    
    // LA entry points for concat_expression
    
    // LA entry points for logical_OR_expression
    
    // LA entry points for logical_AND_expression
    
    // LA entry points for equal_expression
    
    // LA entry points for add_expression
    
    // LA entry points for mult_expression
    
    // LA entry points for func_call_expression
    
    // LA entry points for argument_list
    
    // LA entry points for value_expression
    
    
    
  private: // methods
    
    void consumeToken (int tId) 
    {
      if ((token = scanner.la())->id != tId)
      {
        ParseException pex(scanner.la()->bPos, "Parse error.");
        if (!onParseError(pex)) throw pex;
      }
      scanner.unchecked_consume();
    }
    
    bool laConsumeToken (int tId) 
    {
      if (scanner.la()->id != tId) return false;
      scanner.unchecked_consume();
      return true;
    }
    
  public: // data
    
    scriptScanner scanner;
    int _la;
    scriptToken *token;
    
  private: // user code
  
		public:
		
		/* Wird aufgerufen, wenn im Parser ein Fehler passiert. z.B. falsche Anordnung von
		Tokens, die auf kein Pattern passen. */		
		bool onParseError(ParseException e)
		{
			cout << "In line " << e.where().ln << " near " << e.where().col 
				 << " is an error: " << e.what() << endl;
			return true;
		}				
	

  
}; //end class scriptParser


} //end namespace script_tut


#endif // ifndef __SCRIPT_PARSER_HH__


/* End of file. */
